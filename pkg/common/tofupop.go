package common

import (
	"crypto/ed25519"
	"crypto/rand"
	"crypto/sha1" //nolint: gosec // SHA1 use is according to specification
	"crypto/sha256"
	"crypto/x509"
	"encoding/hex"
	"errors"
	"fmt"
	"math/big"

	"github.com/spiffe/go-spiffe/v2/spiffeid"
	"github.com/spiffe/spire/pkg/common/agentpathtemplate"
	"github.com/spiffe/spire/pkg/common/idutil"
)

const (
	nonceLen = 32

	// PluginName for generated key Proof of Possession
	PluginName = "tofupop"
)

// DefaultAgentPathTemplate is the default template
var DefaultAgentPathTemplate = agentpathtemplate.MustParse("/{{ .PluginName }}/{{ .Fingerprint }}")

// @@TODO
// 1. ed25519.PublicKey
// 2. SHA of device fingerprint

type agentPathTemplateData struct {
	*x509.Certificate
	SerialNumberHex string
	Fingerprint     string
	PluginName      string
	TrustDomain     string
}

// @@TODO: must change the attestation data to be a set of fingerprint
// items for a server host
// & signature over attested data

type AttestationData struct {
	// fingerprint is some data captured from the node
	// and signed into signature with the private key
	// corresponding to the public key provided
	Fingerprint [32]byte `json:"fingerprint"`
	Signature []byte `json:"signature"`
	PublicKey []byte `json:"public"`
}

type EDSignatureChallenge struct {
	// Nonce is the nonce generated by the challenger.
	Nonce []byte `json:"nonce"`
}

type EDSignatureResponse struct {
	// Nonce is the nonce generated by the responder.
	Nonce []byte `json:"nonce"`

	// Signature is the RSA signature of the combined challenger and responder
	// nonces.
	Signature []byte `json:"signature"`
}

// message types (I think?)
type Challenge struct {
	EDSignature   *EDSignatureChallenge   `json:"ed_signature"`
}

type Response struct {
	EDSignature   *EDSignatureResponse   `json:"ed_signature"`
}

// SERVER ONLY, using its certificate
func GenerateChallenge(publicKey *ed25519.PublicKey) (*Challenge, error) {

	challenge, err := GenerateEDSignatureChallenge()
	if err != nil {
		return nil, err
	}
	return &Challenge{
		EDSignature: challenge,
	}, nil
}

func CalculateResponse(privateKey any, challenge *Challenge) (*Response, error) {
	switch privateKey := privateKey.(type) {
	case *ed25519.PrivateKey:

		edChallenge := challenge.EDSignature

		if edChallenge == nil {
	 		return nil, errors.New("expecting RSA challenge")
	 	}
		
	 	response, err := CalculateEDSignatureResponse(privateKey, edChallenge)

	 	if err != nil {
	 		return nil, err
	 	}

	 	return &Response{
	 		EDSignature: response,
	 	}, nil
		
	default:
		return nil, fmt.Errorf("unsupported private key type %T", privateKey)
	}
}

func VerifyChallengeResponse(publicKey any, challenge *Challenge, response *Response) error {
	switch publicKey := publicKey.(type) {
	case *ed25519.PublicKey:
		if challenge.EDSignature == nil {
			return errors.New("expecting ED25519 challenge")
		}
		if response.EDSignature == nil {
			return errors.New("expecting ED25519 response")
		}
		return VerifyEDSignatureResponse(publicKey, challenge.EDSignature, response.EDSignature)
	// case *ecdsa.PublicKey:
	// 	if challenge.ECDSASignature == nil {
	// 		return errors.New("expecting ECDSA challenge")
	// 	}
	// 	if response.ECDSASignature == nil {
	// 		return errors.New("expecting ECDSA response")
	// 	}
	// 	return VerifyECDSASignatureResponse(publicKey, challenge.ECDSASignature, response.ECDSASignature)
	default:
		return fmt.Errorf("unsupported private key type %T", publicKey)
	}
}

func GenerateEDSignatureChallenge() (*EDSignatureChallenge, error) {
	nonce, err := generateNonce()
	if err != nil {
		return nil, err
	}

	return &EDSignatureChallenge{
		Nonce: nonce,
	}, nil
}

func CalculateEDSignatureResponse(privateKey *ed25519.PrivateKey, challenge *EDSignatureChallenge) (*EDSignatureResponse, error) {

	nonce, err := generateNonce()

	if err != nil {
		return nil, err
	}

	combined, err := combineNonces(challenge.Nonce, nonce)

	if err != nil {
		return nil, err
	}

	// @@TODO: sign with ed25519 mech
	signature, err := privateKey.Sign(nil, combined, &ed25519.Options{Context: "SPIRE AGENT NODE SIGNED CHALLENGE"})

	if err != nil {
		return nil, err
	}

	return &EDSignatureResponse{
		Signature: signature,
		Nonce:     nonce,
	}, nil
}

func VerifyEDSignatureResponse(publicKey *ed25519.PublicKey, challenge *EDSignatureChallenge, response *EDSignatureResponse) error {

	combined, err := combineNonces(challenge.Nonce, response.Nonce)

	if err != nil {
		return err
	}

	// @@TODO ed25519 verify
	
	if err := ed25519.Verify(*publicKey, combined, response.Signature); err != true {
		return errors.New("ED25519 signature verify failed")
	}
	
	return nil
}

func Fingerprint(cert *x509.Certificate) string {
	sum := sha1.Sum(cert.Raw) //nolint: gosec // SHA1 use is according to specification
	return hex.EncodeToString(sum[:])
}

// MakeAgentID creates an agent ID from X.509 certificate data.
func MakeAgentID(td spiffeid.TrustDomain, agentPathTemplate *agentpathtemplate.Template, cert *x509.Certificate) (spiffeid.ID, error) {
	agentPath, err := agentPathTemplate.Execute(agentPathTemplateData{
		Certificate:     cert,
		PluginName:      PluginName,
		SerialNumberHex: SerialNumberHex(cert.SerialNumber),
		Fingerprint:     Fingerprint(cert),
	})
	if err != nil {
		return spiffeid.ID{}, err
	}

	return idutil.AgentID(td, agentPath)
}

// SerialNumberHex returns a certificate serial number represented as lowercase hexadecimal with an even number of characters
func SerialNumberHex(serialNumber *big.Int) string {
	serialHex := fmt.Sprintf("%x", serialNumber)
	if len(serialHex)%2 == 1 {
		// Append leading 0 in cases where hexadecimal representation is odd number of characters
		// in order to be more consistent with other tooling that displays certificate serial numbers.
		serialHex = "0" + serialHex
	}

	return serialHex
}

func generateNonce() ([]byte, error) {
	b := make([]byte, nonceLen)
	if _, err := rand.Read(b); err != nil {
		return nil, err
	}
	return b, nil
}

func combineNonces(challenge, response []byte) ([]byte, error) {
	if len(challenge) != nonceLen {
		return nil, errors.New("invalid challenge nonce")
	}
	if len(response) != nonceLen {
		return nil, errors.New("invalid response nonce")
	}
	h := sha256.New()
	// write the challenge and response and ignore errors since it won't fail
	// writing to the digest
	_, _ = h.Write(challenge)
	_, _ = h.Write(response)
	return h.Sum(nil), nil
}
